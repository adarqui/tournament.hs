-- | Tests for the 'Tournament' module.
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Main where

import qualified Game.Tournament as T
import Test.QuickCheck
import Data.List ((\\), nub, genericLength)
import Control.Monad (liftM)
import Test.Framework (defaultMain, testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)

-- helper instances for positive short ints
newtype RInt = RInt {rInt :: Int} deriving (Eq, Ord, Show, Num, Integral, Real, Enum)
newtype SInt = SInt {sInt :: Int} deriving (Eq, Ord, Show, Num, Integral, Real, Enum)
instance Arbitrary RInt where arbitrary = liftM RInt (choose (1, 256) :: Gen Int)
instance Arbitrary SInt where arbitrary = liftM SInt (choose (1, 16) :: Gen Int)

-- -----------------------------------------------------------------------------
-- inGroupsOf
-- test positive n <= 256, s <= 16
type GroupArgs = (RInt, SInt)

-- group sizes <= input size
groupsProp1 :: GroupArgs -> Bool
groupsProp1 (n', s') = maximum (map length (n `T.inGroupsOf` s)) <= s where
  (n, s) = (fromIntegral n', fromIntegral s')

-- players included == [1..n]
groupsProp2 :: GroupArgs -> Bool
groupsProp2 (n', s') = length pls == n && null (pls \\ [1..n]) where
  pls = concat $ n `T.inGroupsOf` s
  (n, s) = (fromIntegral n', fromIntegral s')

-- sum of seeds of groups in full groups differ by at most num_groups
groupsProp3 :: GroupArgs -> Property
groupsProp3 (n', s') = n `mod` s == 0 ==>
  maximum gsums <= minimum gsums + length gs where
    gs = n `T.inGroupsOf` s
    gsums = map sum gs
    (n, s) = (fromIntegral n', fromIntegral s')

-- sum of seeds is perfect when groups are full and even sized
groupsProp4 :: GroupArgs -> Property
groupsProp4 (n', s') = n `mod` s == 0 && even s ==>
  maximum gsums == minimum gsums where
    gsums = map sum $ n `T.inGroupsOf` s
    (n, s) = (fromIntegral n', fromIntegral s')

-- -----------------------------------------------------------------------------
-- robin
-- test positive n <= 256

-- correct number of rounds
robinProp1 :: RInt -> Bool
robinProp1 n =
  (if odd n then n else n-1) == (genericLength . T.robin) n

-- each round contains the correct number of matches
robinProp2 :: RInt -> Bool
robinProp2 n =
  all (== n `div` 2) $ map (genericLength) $ T.robin n

-- a player is uniquely listed in each round
robinProp3 :: RInt -> Bool
robinProp3 n = map nub plrs == plrs where
  plrs = map (concatMap (\(x,y) -> [x,y])) $ T.robin n

-- a player is playing all opponents [hence all exactly once by 3]
robinProp4 :: RInt -> Bool
robinProp4 n = all (\i -> [1..n] \\ combatants i == [i]) [1..n] where
  pairsFor k = concatMap (filter (\(x,y) -> x == k || y == k)) $ T.robin n
  combatants k = map (\(x,y) -> if x == k then y else x) $ pairsFor k

-- -----------------------------------------------------------------------------
-- seeds
-- test positive p <= 256, i <= 16
type SeedsArgs = (RInt, SInt)

-- Test using exported duelValid function.
-- All pairs generated by the function should satisfy this by construction.
seedsProps :: SeedsArgs -> Property
seedsProps (p', i') = i < 2^(p-1) ==> T.duelExpected p $ T.seeds p i
  where (p, i) = (fromIntegral p', fromIntegral i')

-- -----------------------------------------------------------------------------
-- elimination
-- test positive n <= 256

upd :: MatchId -> [Score] -> State Tournament ()
upd id sc = do
  t <- get
  put $ T.score id sc t
  return ()

manipSingle :: State Tournament ()
manipSingle = do
  upd (MID WB (R 1) (G 2)) [2,3]
  upd (MID WB (R 1) (G 3)) [1,2]
  upd (MID WB (R 1) (G 4)) [0,1]

  upd (MID WB (R 2) (G 1)) [1,0]
  upd (MID WB (R 2) (G 2)) [1,0]

  upd (MID WB (R 3) (G 1)) [1,0]
  return ()

manipDouble :: State Tournament ()
manipDouble = do
  --upd (MID WB (R 1) (G 1)) [1,0]
  upd (MID WB (R 1) (G 2)) [0,1]
  --upd (MID WB (R 1) (G 3)) [1,0]
  --upd (MID WB (R 1) (G 4)) [0,1]

  upd (MID WB (R 2) (G 1)) [1,0]
  upd (MID WB (R 2) (G 2)) [0,1]

  upd (MID LB (R 2) (G 1)) [1,0]
  upd (MID LB (R 3) (G 1)) [1,0]

  upd (MID WB (R 3) (G 1)) [1,0]
  upd (MID LB (R 4) (G 1)) [1,0]
  upd (MID LB (R 5) (G 1)) [0,3] -- gf1
  upd (MID LB (R 6) (G 1)) [1,2]

  return ()

-- strategy:
-- generate a tournament of size SInt
-- of Type Elimination determined by bool.
-- get all matches ready to be scored:
-- msrdy <- gets $ Map.filter (all (>0) scores)
-- score all matches:
-- Map.map (swap upd [1,0]) -- always score == [1,0]

-- -----------------------------------------------------------------------------
-- Test harness

tests = [
    testGroup "seeds" [
      testProperty "seeds produce duelValid True pairs" seedsProps
    ]
  , testGroup "robin" [
      testProperty "robin num rounds" robinProp1
    , testProperty "robin num matches" robinProp2
    , testProperty "robin unique round players" robinProp3
    , testProperty "robin all plaid all" robinProp4
    ]
  , testGroup "inGroupsOf" [
      testProperty "group sizes all <= input s" groupsProp1
    , testProperty "group includes all [1..n]" groupsProp2
    , testProperty "group sum of seeds max diff" groupsProp3
    , testProperty "group sum of seeds min diff" groupsProp4
    ]
  ]

main :: IO ()
main = defaultMain tests
